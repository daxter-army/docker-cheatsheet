# docker-cheatsheet

## Containers

- `docker ps`: Show all running containers.
- `docker ps -a`: Show all running/stopped containers, that existed on sometime in docker.

* `docker rm <container_name> | <container_id>`: Delete docker container
* `docker rm <container_name> | <container_id> -f`: Delete docker container, focefully if it is currently running.

- `docker stop <container_id> or <container_name>`: Stop a running container.
- `docker start <container_id>`: Run a stopped container.
- `docker logs <container_name>`: Show the logs of the container, typically used for detached containers.
- `docker export <container_name> > <file_name>.tar`: It outputs the contents of your container in a .tar file.
- `docker kill <container_id>`: Kill running docker container.
- `docker exec -it <container_name> <command_to_run>`: This will run the command inside docker container, and we can go inside the docker container, like we go insider folders in our host OS. We can only execute this when the container is actually running.
- `docker exec -it <container_name> bash`: This will open the docker container in bash terminal.
<!-- shinjansengar@gmail.com -->

## Images

- `docker images`: Show all the docker present on the system.
- `docker image rm <image_id> | <image_name>`: Delete docker images from your local machine.

* `docker run -d -p <host_machine_port>:<container_port> <image_name>:<image_tag>`: Run a container from image in detached mode and expose its port.
  - `-d`: Run container in detached mode, do not display the logs which are produced by the program running inside container.
  - `-p`: To access our containerised app from our PC, expose the internal port of the container to the external machine.
  - `-e`: Provide environmental values to your container, which eventually are provided to your app.
  - `--env-file ./.env`: You can also directly use your .env files

- `docker build -t <image_name>:<image_tag> .`: Build docker image of this name and version, from this location, the location in which the Dockerfile is located

## Reposity v/s Registry

### Registry

- A service providing storage for you docker images, that can be hosted anywhere like AWS ECR etc.
- A registry can have multiple images or we can say multiple repositories for you application.

### Repository

- Collection of related images with same name, but with different versions.

## Reduce docker image build time

- Docker images are build in layers, each command is a layer, and Docker tries to cache the result of every layer.
- If a layer is changed, the layers below that layers are rebuilded again.

- Try to keep commands together which are less bounded to change, e.g

```dockerfile
COPY src ./src/
COPY package.json ./
COPY public ./public/
```

- Here when you are developing something, changes of `src` getting changed are more as compared to changing of `package.json` and `public` folder. So if `src` is changed often, docker build will also create new build for all the layers below that layer, therefore to reduce build time we can do like this:

```dockerfile
COPY package.json ./
COPY public ./public/
COPY src ./src/
```

## Volumes

- Docker volumes are file systems mounted on Docker containers to preserve data generated by the running container or to write the data from our host OS to fs present in container. This allows you to sync your local directory to a directory present inside docker container.

* There 3 types of Docker volume types:

1. **Host Volumes**: Changes from host OS are written inside docker and vice-versa.

- `docker run -v <local_directory>:<container_dir> -d -p <host_machine_port>:<container_port> <image_name>:<image_tag>`: Bi-directionally changes are written.

- `docker run -v <local_directory>:<container_dir>:ro -d -p <host_machine_port>:<container_port> <image_name>:<image_tag>`: Changes from outside to docker are written, but from docker to outside are not written, i.e Read only mode.
  - `docker run -v /home/daxter-army/Desktop/daxter-army.github.io/src:/app/src -p 3000:3000 portfolio-app:1.2`
  - `docker run -v $(pwd)/src:/app/src -p 3000:3000 portfolio-app:1.2`

2. **Anonymous Volumes**: Location on the Host OS is automatically generated by the container. Command `docker run -v <container_dir> -d -p <host_machine_port>:<container_port> <image_name>:<image_tag>`

3. **Named Volumes**: An alias is created for the path, and you can mount 1 directory to different paths in different containers if needed.

# docker compose

- Suppose if we have one docker for react app, second for express server, and one docker container for mongoDB, then it would become difficult for us to manage them at development, and we would be managing the docker containers all the time leading to no development. That's where docker compose kicks in. Docker compose is a utility which helps us to manage multi-dockered development process.

* `docker-compose` is v1
* `docker compose` is v2, use v2
